# 乐观锁与悲观锁

[什么是乐观锁，什么是悲观锁 - 简书 (jianshu.com)](https://www.jianshu.com/p/d2ac26ca6525)

## 并发控制

#### 定义

当程序中可能出现并发的情况时，就需要通过一定的手段来**保证在并发情况下数据的准确性**，通过这种手段保证了**当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。**这种手段就叫做**并发控制**。**并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。**

#### 如果没做好可能出现的问题

[脏读、不可重复读、幻读区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/fcdb2815b21f)

+ **脏读:**脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改**还没有提交到数据库中**，这时，另外一个事务也访问这个数据，然后使用了这个数据。
+ **幻读:**是指当事务**不是独立执行**时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，**这种修改涉及到表中的全部数据行**。 同时，第二个事务也修改这个表中的数据，这种修改是**向表中插入一行新数据(第一个事务的修改没有影响到他)**。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。
  + 例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。 如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。
+ **不可重复读:**是指在一个事务内，**多次读同一数据**。在这个事务还没有结束时，另外一个事务也访问该同一数据并做了修改。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了**在一个事务内两次读到的数据是不一样的**，因此称为是不 可重复读。
  + 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

## 悲观锁(Pessimistic Concurrency Control，缩写“PCC”)

#### 理解:

+ 正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。
+ 因此，在整个数据处理过程中，将数据处于锁定状态。
+ 悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。
+ 因为这是一种对数据的修改**持有悲观态度的并发控制方式**。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。
+ 实现方式:
  + 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
  + Java 里面的同步 [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字的实现。

#### 分类

##### 共享锁(shared locks 读锁 )

顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都**能访问到数据**，但是**只能读不能修改**。

##### 排他锁(exclusive locks 写锁 )

顾名思义，排他锁就是**不能与其他锁并存**，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，**但是获取排他锁的事务是可以对数据行读取和修改。**

## 乐观锁(Optimistic Locking)

#### 理解：

+ 乐观锁是相对悲观锁而言的，乐观锁**假设数据一般情况下不会造成冲突**，所以**在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测**，如果发现冲突了，则**返回给用户错误的信息**，让用户决定如何去做。**乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。**
+ 乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是**依据数据本身来保证数据的正确性**。
+ 乐观锁的实现：
  + [CAS 实现](https://www.jianshu.com/p/98220486426a)：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
  + 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，**若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。**
+ 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，**所以不会产生任何锁和死锁。**

## 具体实现

### 悲观锁的实现方式

悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：

1. 在对记录进行修改前，先尝试为该记录加上排他锁(exclusive locks)。
2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
3. 如果成功加锁，那么就可以对记录做修改，[事务](https://www.jianshu.com/p/7e76ce65e3ad)完成后就会解锁了。
4. **执行事务期间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。**

要使用悲观锁，必须关闭 [MySQL](https://www.jianshu.com/p/359c3fe50c7f) 数据库的自动提交属性。因为 MySQL 默认使用 autocommit 模式，也就是说，当执行一个更新操作后，MySQL 会立刻将结果进行提交。(sql语句：set autocommit=0)

**扩展一下**：这也是为什么数据库操作时先开启事务再进行操作更有效率的原因。再begin和end之间查询数据的话，这样事务会在缓冲区缓存为独立事务，并会被分配特定内存，以此来提高处理速度。不然每单独查一次都是一次事务提交，消耗太大。

### 乐观锁实现方式

CAS技术\Version的控制

## 五、如何选择

在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。
 1️⃣**响应效率**：如果需要非常高的响应速度，建议采**用乐观锁方案**，成功就执行，不成功就失败，不需要等待其他并发去释放锁。乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
 2️⃣**冲突频率**：如果冲突频率非常高，建议采**用悲观锁**，保证成功率。冲突频率大，选择乐观锁会需要多次重试才能成功，代价比较大。
 3️⃣**重试代价**：如果重试代价大，建议采用**悲观锁**。悲观锁依赖数据库锁，效率低。更新失败的概率比较低。
 4️⃣**乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。悲观锁则会等待前一个更新完成。这也是区别。**







