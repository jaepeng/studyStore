# 事件分发机制

### 事件类别

![image-20201127144759633](https://gitee.com/pengjae/pic/raw/master/img/20201127144759.png)

**注意**:ACTION_MOV会在手指移动时触发多次

### View继承关系

![image-20201127145343338](https://gitee.com/pengjae/pic/raw/master/img/20201127145343.png)

### 事件分发流程

![image-20201127145523875](https://gitee.com/pengjae/pic/raw/master/img/20201127145523.png)

而实际上Activity和ViewGroup容器,都是通过ViewGroup的dispatchTouchEvent分发的。



如果同时设置：点击事件和Touch事件的话：

```java
private void initEvent() {
        mClilck_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.d(TAG, "onClick: ");
            }
        });
        mClilck_btn.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                Log.d(TAG, "onTouch: "+event.getAction());
                //修改成true的话，在这里该事件就被消费掉了，不会去调用onClick()
                return false;
            }
        });
    }
//TouchAction:
0:ACTION_DOWN
1:ACTION_UP
2:ACTION_MOVE
```

### **onTouch中返回值为false**（默认值）

情况一：按下按钮，拖动了一会（控件范围内）再移开打 印结果（OnTouch中retrunfasle）

![image-20201127151400904](https://gitee.com/pengjae/pic/raw/master/img/20201127151400.png)

**注意**：是在onTouch事件结束之后调用的

情况二：按下按钮，拖动出了控件范围内：没有触发onClick事件

![image-20201127151639966](https://gitee.com/pengjae/pic/raw/master/img/20201127151639.png)

### **onTouch中返回值为true**

情况一：如果按下按钮后一直拖动，无论是否超出控件范围都会一直在move状态中

![image-20201127151959313](https://gitee.com/pengjae/pic/raw/master/img/20201127151959.png)

情况二：点击按钮就拿开，不会触发onClick事件

![image-20201127152030490](https://gitee.com/pengjae/pic/raw/master/img/20201127152030.png)

**解释：**如果在onTouch方法中返回true的话，说明在这里该事件就被消费掉了，而不会进而传递到onClick中。



在View.java的dispatchTouchEvent中有这么一段代码

```java
//mListnerInfo在调用onTouch方法时调用getListenerInfo时会初始化
ListenerInfo li = mListenerInfo;
if (li != null && li.mOnTouchListener != null
                    && (mViewFlags & ENABLED_MASK) == ENABLED
                    && li.mOnTouchListener.onTouch(this, event)) {
                result = true;
}

//由于java是短路语句，如果想要执行到onTouch方法，前面的条件都必须满足
如果onTouch返回值为false，则该判定条件为false，那么result会返回默认值false，而不会修改成true
```

```java
ListenerInfo getListenerInfo() {
        if (mListenerInfo != null) {
            return mListenerInfo;
        }
        mListenerInfo = new ListenerInfo();
        return mListenerInfo;
}


//设置点击事件时会调用getListenerInfo方法
 public void setOnTouchListener(OnTouchListener l) {
        getListenerInfo().mOnTouchListener = l;
    }
```

### 那为什么onTouch设置成true后，onClick事件不会被调用呢

```java
//View的dispatchTouchEvent代码中，就在前面代码的后面，有这么一段
if (!result && onTouchEvent(event)) {
                result = true;
}
```

1. result为fasle是由于onTouch的返回值决定的
2. 而且只有result为fasle时onTouchEvent会执行。
3. 而onTouchEvent中就是对四个事件的处理（down、up、cancel、move）
4. onClickLisetener就是在ACTION_UP中使用到的 

```java
//从UP事件的performClickInternal调到View中的performClick然后调到了View中的performClick（）方法
if (li != null && li.mOnClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            li.mOnClickListener.onClick(this);//执行了onClick方法
            result = true;
        } else {
            result = false;
}
//注意，这里处理外事件后将result设置成了true。代表事件被消费掉了。
```

**result返回true的用处：**通知父容器，我已经将事件完成了。这也就是为什么，如果不给控件添加事件的话，是没有任何用处的原因，因为默认返回false，就是不去处理。

## 冲突解决方法

> 以下代码以一个ViewPager包裹ListView为例

### 内部拦截法

> 由子View处理事件，要保证[第二块代码](#secondCode)一定要执行，那就是保证intercepted一定要为false



### 外部拦截法

> 事件交给ViewGrop根据情况分发

## 将ViewGroup中的dispatchTouchEvent（）分为三大块

### <span id ="fc">第一块</span>:是否拦截子View，即是否将事件分发给子View

```java
if (actionMasked == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
    
}else{
    
}
```

### <span id="secondCode">第二块代码</span>:遍历子View，选择发给哪个子View进行处理事件

```java
if (!canceled && !intercepted) {}
```

### <span id = "thridCode">第三块代码：</span>

+ 如果没有子View处理事件，**询问**自己是否处理（不是没人处理，自己就处理）事件，否则就是子View处理，（down：直接返回true，move：才回去询问子View处理事件）

```java
if (mFirstTouchTarget == null) {
    // No touch targets so treat this as an ordinary view.
    handled = dispatchTransformedTouchEvent(ev, canceled, null,
            TouchTarget.ALL_POINTER_IDS);
} else {}//进行处理
```

### 需要解决冲突的事件主要分为：

#### Down

1. 为什么ViewPager中onInterceptTouchEvent返回为true,**上下**不能滑动

   + 首先先进入ViewPager的dispatchTouchEvent

   + ```java
     //由于是down事件,所以disallowIntercept为false,会进入该判定语句中
     if (!disallowIntercept) {
     	intercepted = onInterceptTouchEvent(ev);//一定执行
     	ev.setAction(action); // restore action in case it was changed
     } else {
     	intercepted = false;
     }
     ```

   + 因为进入了if语句所以 **onInterceptTouchEvent**方法一定会执行（对不对子View进行拦截）

   + 而我们如果直接返回true的话，那么intercepted为true，而这个为true的话[第二块代码](#secondCode)就**不会被执行(判断条件里面有!intercepted)**，那就是说不回去遍历子View，选择发给哪个View处理事件

   + 那么就会去执行[第三块代码](#thridCode),由于mFirstTourchTarget为空，就会进入执行内部的语句

     + ```java
       //询问自己是否处理事件的方法，由于child的参数为null，所以就询问自己是否处理ev事件
       handled = dispatchTransformedTouchEvent(ev, canceled, null,
                   TouchTarget.ALL_POINTER_IDS);
       ```

     + 这里调用该方法，由于child为null，则会调用`super.dispatchTouchEvent()`而ViewGroup的super方法指的就是VIew的`dispatchTouchEvent`方法

     + 返回的handled为true标识处理该事件，false表示不处理该事件

   + 所以如果ViewPager的onInterceptTouchEvent返回ture的话，代表ViewPager将该事件消费了，那么事件就不会传递给ListView了。

2. 为什么ViewPager中onInterceptTouchEvent返回为false,**左右**不能滑动

   + 前面是一样的，到了进入了if语句所以 **onInterceptTouchEvent**方法一定会执行之后，由于我们返回的是false，那么[第二块代码](#secondCode)就会被执行.
   
   + 既然第二块代码执行，那么就会去遍历子View，将事件分发给子View执行
     + 只有是down事件的时候才会去分发事件给子View。（后面的条件是多指操作和鼠标操作）
     + childCount指的是直属View，子View中包含的View是不算的。
     + 添加View的时候 ，他是按照先后顺序将组件放入一个ArrayList中。而点击事件处理，是从最后的View开始，逐级向上
     + 但是这里有一点,当**进入ListView的dispatchTouchEvent中**时,由于它已经没有子view了,即childCount==0,所以会马上退出来
     
   + 开始询问child是否处理该事件,处理返回true,不处理返回false
   
     ```java
     注意,前面也是同样的方法,但是传入的参数是nulll,而这里是child
     //第二块代码
      if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {//询问子View是否处理事件,这里选择了处理
        // Child wants to receive touch within its bounds.
        mLastTouchDownTime = ev.getDownTime();
        if (preorderedList != null) {
               // childIndex points into presorted list, find original index
        		for (int j = 0; j < childrenCount; j++) {
               	if (children[childIndex] == mChildren[j]) {
              		mLastTouchDownIndex = j;
              		break;
             	}
        		}
         } else {
               mLastTouchDownIndex = childIndex;
         }
         mLastTouchDownX = ev.getX();
         mLastTouchDownY = ev.getY();
         newTouchTarget = addTouchTarget(child, idBitsToAssign);//addTouchTarget
         alreadyDispatchedToNewTouchTarget = true;
         
     }
     ```
   
     + ```java
       newTouchTarget = addTouchTarget(child, idBitsToAssign);==mFirstTouchTarget!=null
       target.next=null
       alreadyDispatchedToNewTouchTarget = true;//第二块代码尾部对该属性就行设置
       ```
   
     + ```java
       private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
           final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);  //获得一个TouchTarget
           target.next = mFirstTouchTarget;
           mFirstTouchTarget = target;//mFirstTouchTarget=!null
           return target;
       }
       ```
   
     + ```java
       
       ```
   
   + 走[第三块代码](#thridCode)由于mFirstTouchTarget已经不为null了,那么就会进入else语句
   
     + 走进去之后,由于`target.next==null`则while循环只走一次.所以是**直接返回true;**
   
     + ```java
       TouchTarget predecessor = null;
       TouchTarget target = mFirstTouchTarget;
       while (target != null) {
           final TouchTarget next = target.next;
           if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {//全部满足条件
               handled = true;//被设置成true
           } else {
               final boolean cancelChild = resetCancelNextUpFlag(target.child)
                       || intercepted;
               if (dispatchTransformedTouchEvent(ev, cancelChild,
                       target.child, target.pointerIdBits)) {
                   handled = true;
               }
               if (cancelChild) {
                   if (predecessor == null) {
                       mFirstTouchTarget = next;
                   } else {
                       predecessor.next = next;
                   }
                   target.recycle();
                   target = next;
                   continue;
               }
           }
           predecessor = target;
           target = next;
       }
       ```
   
     + 由于if判断满足,handled被设置成true,后来target又被设置成next==null了,所以循环被退出,而handled被保留成true,直接返回true
   
   + 所以这里进入到ListView的事件后,**handled设置成true**,事件就已经被消费掉了,所以Viewpager分发不到事件,所以只能上下滑动,不能左右滑动（父容器处理了事件）
   
3. 为什么子View(ListView)实现dispatchTouchEvent返回false时并且ViewPage（父容器）中的onInterceptTouchEvent也返回false时（不对子View进行拦截）。,上下不行,左右可以

   1. 总体思路与第二问类似,但是由于我们将ListView的dispartchV设置成fasle

   2. ```java
      //询问子View是否处理事件,由于ListView没有子View了,那就去询问自己是否处理此事件,
      //因为我们自己设置 dispatchTouchEvent返回false，选择了不处理，handled也被设置成了false。
      //由于只有一个ListView是子View，那么第二块代码执行完毕 那么就要进入第三块代码
      //第二块代码
      if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {}
      ```

   3. 这里的情况就和第个问题的情况一样了, 由于在第二块代码选择了不处理事件,所以进入[第三块代码](#thridCode)

      ```java
      //进入第三块代码:
      
      //就是ViewPage去处理该事件
      if (mFirstTouchTarget == null) {//由于前面没有进行赋值，所以还是null的，条件成立
         //询问自己是否处理事件的方法，由于child的参数为null，所以就询问自己是否处理ev事件
          handled = dispatchTransformedTouchEvent(ev, canceled, null,
                  TouchTarget.ALL_POINTER_IDS);
      } else {}
      ```

   4. 

4. 为什么会产生冲突？

   1. 因为事件只有一个View去处理
   2. google做了处理，所以有时候不做处理反而能做的到效果。

#### Move

5. onInterceptTouchEvent处理冲突时，为什么要先down然后再返回false

   1. 必须要走入[第二块代码](#secondCode),去遍历子View，让子View去处理事件(内部拦截法)。而由于down事件 onInterceptTouchEvent一定会被执行，所以需要将这个置为false，只有它为false，第二块代码才会被执行

6. 为什么这样能解决冲突

   1. 隐藏问题：这个事件（已经分发给子View处理了）是怎么由子View转到父容器的（主要还是看move）

      1. down事件给ListView之后，ListView已经同意处理，并且已经处理完成了，现在进来的是Move事件

      2. Move事件进来后，调用ViewGroup中的dispatchTouchEvent方法

      3. 由于不是Down事件了，

      4. ```java
         newTouchTarget = addTouchTarget(child, idBitsToAssign);==mFirstTouchTarget!=null
         target.next=null
         ```

      5. ```java
         if (actionMasked == MotionEvent.ACTION_DOWN
                 || mFirstTouchTarget != null) {
             final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
             //由于我们再代码中再Down事件时，将disallowIntercept设置会true，所以不会进入下面这个判断
             //所以，ViewPager中就算onInterceptTouchEvent返回的是true，也没有关系，已经不去处理了
             if (!disallowIntercept) {
                 intercepted = onInterceptTouchEvent(ev);
                 ev.setAction(action); // restore action in case it was changed
             } else {
                 intercepted = false;
             }
         } else {}
         ```

      6. 所以[第一块代码](#fc)拦截不了子View，进入[第二块代码](#secondCode).

      7. ```java
         boolean alreadyDispatchedToNewTouchTarget = false;
         if (!canceled && !intercepted) {
             View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                     ? findChildWithAccessibilityFocus() : null;
             if (actionMasked == MotionEvent.ACTION_DOWN//是move事件，不是down事件，所以不会进入然后分发
                     || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                     || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
         ```

      8. 第二块代码不会进去分发后，进入[第三块代码](#thridCode)

      9. ```java
         //第三块代码
         if (mFirstTouchTarget == null) {
             // No touch targets so treat this as an ordinary view.
             handled = dispatchTransformedTouchEvent(ev, canceled, null,
                     TouchTarget.ALL_POINTER_IDS);
         } else {//由于mFirstTouchTarget不为null了，则会进入该else语句中
           
             TouchTarget predecessor = null;
             TouchTarget target = mFirstTouchTarget;
             //这个while循环还是只会走一次，
             while (target != null) {
                 final TouchTarget next = target.next;
                 //但是这次if条件不满足，由于第二块代码没有进去，所以alreadyDispatchedToNewTouchTarget还是为false
                 if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                     handled = true;
                 } else {
                     final boolean cancelChild = resetCancelNextUpFlag(target.child)
                             || intercepted;//intercepted这个条件非常关键！！
                     //询问target.child（ListView）要不要去处理事件。
         				//代码中进行了设置，如果滑动y>x，则让ListView自己去处理事件
         				//x>y则设置reqyestDisallowInterceptTouchEvent（false）
         					//第一块代码中的条件就改变了（disallowIntercept=false)则会让父控件进行拦截
                        		//由于会被拦截则，intercepted被设置为true了。则再这个方法里cancelChild也为ture了  
                     		//如果cancelChild为ture的话，那么这个方法走向就变了
                     if (dispatchTransformedTouchEvent(ev, cancelChild,                         
                             target.child, target.pointerIdBits)) {
                         handled = true;
                     }
                     if (cancelChild) {
                         if (predecessor == null) {
                             mFirstTouchTarget = next;//如果进入这里之后，可以看到mFirstTouchTarget就为null了
                         } else {
                             predecessor.next = next;
                         }
                         target.recycle();
                         target = next;
                         continue;
                     }
                 }
                 predecessor = target;
                 target = next;
             }
         }
         ```

      10. ```java
          由于
          private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
                  View child, int desiredPointerIdBits) {
              final boolean handled;
              final int oldAction = event.getAction();
              if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {//由于cancel为true，则会进入该语句了
                  event.setAction(MotionEvent.ACTION_CANCEL);//Action_cancel就出现了事件被上层拦截了
                  if (child == null) {
                      handled = super.dispatchTouchEvent(event);
                  } else {
                      handled = child.dispatchTouchEvent(event);
                  }
                  event.setAction(oldAction);
                  return handled;
              }
          ```

      11. 如果mFirstTouchTarget为null了,再第一块代码中intercepted被设置为true，则第二块代码不会执行，直接走[第三块代码](#thridCode)

      12. 事件交给ViewGroup处理

